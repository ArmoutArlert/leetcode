/*
// 错误的dp，时间复制度是O(N^2)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n,vector<int>(n));
        int maxValue = INT_MIN;

        for(int i=0;i<n;i++){ 
            for(int j=i;j<n;j++){
                if(i==j){
                    dp[i][j] = nums[i];
                }else{
                    dp[i][j] = dp[i][j-1] + nums[j];
                }
                maxValue = max(maxValue,dp[i][j]);    
            }
        }
        return maxValue;
    }
}; */

// 正确的dp思路
// 最后落实到以nums[i]为最后一个元素的子数组
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
         if(nums.empty()){return -1;}
        int n = nums.size();
         vector<int> dp(n);
        int maxValue = nums[0];
        dp[0] = nums[0];
        for(int i=1;i<n;i++){ 
           dp[i] = dp[i-1]>0 ? dp[i-1]+nums[i] : nums[i];
           maxValue = max(maxValue,dp[i]);
        }
        return maxValue;
    }
};
