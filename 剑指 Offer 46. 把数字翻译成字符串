// 递归的方法，从左到右的方法，注意这道题不用记录路径，所以可以改成动态规划！
// 只要是不用记录路径的的递归都可以尝试改成动态规划
/*
class Solution {
public:
    int count = 0;
    void process(vector<long>& nums,int index){
        if(index == nums.size()){
            // 到尾部了进行计数
            count++;
            return;
        }
        process(nums,index+1);
        // 这个要设计好
        if(index+1 < nums.size() && (nums[index]==1 ||(nums[index]==2 && nums[index+1]<6))){
        process(nums,index+2);
        }
    }

    int translateNum(int num) {
        // 拆分成数组的写法，先取余再除法，注意要改成long，要不然用int会超
        vector<long> nums;
        long a = 1;
        while(num>=a){
            nums.push_back(num%(a*10)/a);
            a = a*10;
        }
        reverse(nums.begin(),nums.end());
        process(nums,0);
        return count;
    }
};*/


// 事实上要考虑负数存在的情况
/*
class Solution {
public:
    int translateNum(int num) {
        if(num==0){return 1;}
        vector<long> nums; 
        long a=1;
        while(num>=a){
           nums.push_back((num%(a*10)/a));
           a *= 10;
        }
        reverse(nums.begin(),nums.end());     
        int n=nums.size();
        vector<int> dp(n);
        for(int i=0;i<n;i++){
           if(i==0){
               dp[0] = 1;
           }
           else if(i==1){
               dp[1]= (nums[0]==1 || (nums[0]==2 && nums[1]<6)) ? 2 : 1;      
           }
           else{
               dp[i]=(nums[i-1]==1 || (nums[i-1]==2 && nums[i]<6)) ? (dp[i-1]+dp[i-2]) : dp[i-1]; 
           }
       }
       return dp[n-1];
    }
};
*/


// 标准答案使用的是to_string()函数，这样就更好处理了
// 省空间dp
class Solution {
public:
    int translateNum(int num) {
        if(num==0){return 1;}
        vector<long> nums; 
        long t=1;
        while(num>=t){
           nums.push_back((num%(t*10)/t));
           t *= 10;
        }
        reverse(nums.begin(),nums.end());     
        int n=nums.size();
        int a = 1,b=1,c=1;
        for(int i=1;i<n;i++){
          if(nums[i-1]==1 || (nums[i-1]==2 && nums[i]<6)){
              c = a+b;
              a=b;b=c;
          }else{
              c = b;
              a = b;
          }
       }
       return c;
    }
};
